"""
Automates the entire asset generation pipeline for the fragmentation comparison.

This single script orchestrates the following workflow:
1. Runs the `run_fragmentation_viz.py` simulation for the 'fragmented' state.
2. Runs the simulation again for the 'clumped' state.
3. Loads the authentic, final population data generated by those simulations.
4. Renders the data into two clean, transparent, presentation-ready PNG assets.
"""

import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from matplotlib.collections import PatchCollection
import numpy as np
import os
import json
import sys
import subprocess
from pathlib import Path

# --- Configuration for Aesthetics ---
OUTPUT_DIR = "presentation_figures"
FIG_SIZE = (8, 12)

# Official project colors
COLOR_WT = "#02343F"
COLOR_M = "#d35400"


# --- Helper function to run the simulation script ---
def run_simulation_script(state: str, project_root: Path):
    """
    Calls the `run_fragmentation_viz.py` script as a subprocess
    to generate the necessary data for a given state.
    """
    script_path = project_root / "scripts" / "run_fragmentation_viz.py"
    python_executable = (
        sys.executable
    )  # Use the same python that is running this script

    command = [python_executable, str(script_path), "--state", state]

    print(f"\n--- Running simulation for '{state}' state... ---")
    print(f"Executing: {' '.join(command)}")

    try:
        # Use subprocess.run to execute the command
        # check=True will raise an error if the script fails
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=True,
            cwd=project_root,  # Run from the project root directory
        )
        print(f"--- Simulation for '{state}' state completed successfully. ---")
        # print(result.stdout) # Uncomment for full output
    except FileNotFoundError:
        print(
            f"❌ Error: Could not find '{python_executable}'. Is Python in your PATH?"
        )
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"❌ Error: The simulation script for state '{state}' failed.")
        print("--- STDERR ---")
        print(e.stderr)
        print("\nAborting asset generation.")
        sys.exit(1)


# --- Data Loading and Hex Grid Drawing Utilities (from previous script) ---
def load_population_data(data_path: Path) -> dict:
    if not data_path.is_file():
        raise FileNotFoundError(f"Data file not found: {data_path}")
    with open(data_path, "r") as f:
        data = json.load(f)
    return {(item["q"], item["r"]): item["type"] for item in data}


def _axial_to_cartesian(q, r, size=1.0):
    x = size * (3.0 / 2.0 * q)
    y = size * (np.sqrt(3) / 2.0 * q + np.sqrt(3) * r)
    return x, y


def _get_hex_corners(center_x, center_y, size=1.0):
    corners = []
    for i in range(6):
        angle_rad = np.pi / 180 * (60 * i)
        corners.append(
            (center_x + size * np.cos(angle_rad), center_y + size * np.sin(angle_rad))
        )
    return np.array(corners)


def render_hex_grid_to_file(population: dict, output_path: Path, hex_size: float = 1.0):
    fig, ax = plt.subplots(figsize=FIG_SIZE)
    fig.set_facecolor("none")
    ax.set_facecolor("none")
    ax.set_aspect("equal")

    patches_wt, patches_m = [], []
    for (q, r), cell_type in population.items():
        center_x, center_y = _axial_to_cartesian(q, r, hex_size)
        corners = _get_hex_corners(center_x, center_y, hex_size)
        polygon = Polygon(corners, closed=True)
        if cell_type == 1:
            patches_wt.append(polygon)
        elif cell_type == 2:
            patches_m.append(polygon)

    ax.add_collection(
        PatchCollection(patches_wt, facecolor=COLOR_WT, edgecolor=COLOR_WT, lw=0.1)
    )
    ax.add_collection(
        PatchCollection(patches_m, facecolor=COLOR_M, edgecolor=COLOR_M, lw=0.1)
    )

    ax.autoscale_view()
    ax.axis("off")

    plt.savefig(
        output_path, dpi=300, transparent=True, bbox_inches="tight", pad_inches=0.05
    )
    plt.close(fig)


def main():
    project_root = Path(__file__).resolve().parent.parent.parent
    base_run_dir = project_root / "figures" / "debug_runs"
    output_dir_path = project_root / OUTPUT_DIR
    output_dir_path.mkdir(exist_ok=True)

    states_to_process = {
        "fragmented": {
            "data_path": base_run_dir
            / "fragmentation_viz_fragmented"
            / "final_population_data.json",
            "output_name": "fragmented_front.png",
        },
        "clumped": {
            "data_path": base_run_dir
            / "fragmentation_viz_clumped"
            / "final_population_data.json",
            "output_name": "clumped_front.png",
        },
    }

    # === STEP 1 & 2: Run the simulations to generate data ===
    run_simulation_script("fragmented", project_root)
    run_simulation_script("clumped", project_root)

    # === STEP 3 & 4: Export the generated data as clean assets ===
    print("\n--- Exporting Clean Image Assets from Simulation Data ---")
    for state, paths in states_to_process.items():
        print(f"\nProcessing '{state}' state...")
        try:
            population_data = load_population_data(paths["data_path"])
            output_path = output_dir_path / paths["output_name"]

            render_hex_grid_to_file(population_data, output_path)

            print(f"✅ Successfully exported asset to: {output_path}")

        except FileNotFoundError as e:
            print(f"  -> ❌ CRITICAL Error: {e}")
            print("  -> The simulation ran but the expected data file was not created.")
            continue

    print("\n✅ Automated asset generation complete.")


if __name__ == "__main__":
    main()
